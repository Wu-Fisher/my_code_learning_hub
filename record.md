# Wufisher leetcode_record

thank ac_oier

update 2021/12/26 not catch

### 384.打乱数组

```
洗牌算法 数组乱序等可能
```

### 519.随机翻转矩阵

```
将二维转为一维，双指针，一个指针从随机到位置向坐，一个向右，每次随机得到不重复的坐标
```

### 53.最大子序和

```
核心思想：利用一个sum保存前面之和大于0，若小于0则代表负影响，更新为新值
```

### 562.矩阵中最长连续1线段

```
分成四个方向的动态规划dp
```

### 1746.经过一次操作后的最大子数组和

```
操作为将一个数平方
最大子数组肯定包含操作，利用两个dp1，2，分别记录当前i个加入进去后（可能操作也可能之前有操作），有操作和无操作的最大值。
```

### 152.乘积最大子数组

```
动态规划需要保存两种情况
以i结尾的最大值，和以i结尾的最小值
乘法和加法存在一定区别，可能负数×小值可能会更大
```

### 458.可怜的小猪

```
毒药问题，检测次数k可以转为k+1进制的一个表示问题
香农熵定理
只数为 LOGM/LOG(K+1)
```

### 423.从英文中重建数字

```
考虑每一个数字在当前选取域独有的字母，例如8的h
优化统计不重复
```

### 859.亲密字符串

```
词频统计，且有一个字符串必须交换一次——》1.恰巧能交换两个2.若完全相同，则必须有一个的词频>1
```

### 376.摆动序列

```
将摆动序列分为最后一个为降down，最后一个为升up两种情况来处理
只用比较i和i-1的值，如果更大，则up变为up和down+1的max（不必考虑i-1是不是up或者down最后一位）由于down和up可以对于新节点可以选择为相对最小和最大值，所以一定能够加入进去
```

### 买卖股票.

```
309.含冷冻期
714.含手续费
121.基础版
```

### 1035.不相交的线

```
字符串匹配动态规划
```

### 599.两个列表最小索引综合？

### 343.整数拆分？
    数学题：将整数优先拆成相等的，乘积最大，且计算出值为e,（2，3比较后选择3）
    如果余数为2，则不再拆分，如果余数为1，则还要把之前的3和这个1组合为2+2
### 64.最小路径和

```
动态规划
```

### 397.整数替换

```
位运算，化为二进制处理问题
```

### 488.祖玛游戏！？？？

### 438.找到字符串中所有异位字词

```
窗口化双指针词频统计，动态更新头尾
优化：利用变量记录当前已经匹配的字母，只用一个词频数组
```

### 653.二叉树的坡度

```
递归遍历左右子树
```

### 487.最大连续1的个数

```
（有一个将0反转为1的机会）
双动态变量，记录包含i且当前连续子串是否使用过翻转的机会，在和ans比较取最大，优化：可以不断输入，且不需要占用空间,dp1记录用过的，dp2记录没用过
```

### 318.最大单词长度乘积
    由于全是小写字母，我们可以用int的二进制数表示该单词出现的字母种类，在利用**位运算**判断是否存在相同字符
    例如‘adb’ ——> 00000..01011（用1的左移和|运算实现）
    优化：利用哈希表，对于相同字母单词只用保存较大的
### 391.完美矩形？
    扫描线算法
    from三叶
    将每个矩形 rectangles[i]rectangles[i]rectangles[i] 看做两条竖直方向的边，使用 (x,y1,y2)(x, y1, y2)(x,y1,y2) 的形式进行存储（其中 y1y1y1 代表该竖边的下端点，y2y2y2 代表竖边的上端点），同时为了区分是矩形的左边还是右边，再引入一个标识位，即以四元组 (x,y1,y2,flag)(x, y1, y2, flag)(x,y1,y2,flag) 的形式进行存储。
    一个完美矩形的充要条件为：对于完美矩形的每一条非边缘的竖边，都「成对」出现（存在两条完全相同的左边和右边重叠在一起）；对于完美矩形的两条边缘竖边，均独立为一条连续的（不重叠）的竖边。
    具体扫描实现办法看代码



### 319.灯泡开关

```
数学题
小于等于n的完全平方数的个数为sqrt(n)，
因子个数奇数有且仅有完全平方数
```

### 1143.最长公共子序列

```
经典动态规划
```

### 667.键值映射

```
tri树变形，只是说将结尾boolean类型改为了val值
```

### 1230.拋掷硬币

```
动态规划，dp[i][j]描述i次抛掷，j次朝上
dp[i][j]=dp[i-1][j-1]*A[i-1]（前i-1次只有j-1）
+dp[i-1][j]*(1-A[i-1])（前i-1有j次）;
```

### 629.K个逆序對数组**

```
二位动态规划，更大的数不会对前面小数的逆序对个数产生影响
优化：利用前缀相同，优化储存求和
```

### 786.第K个最小的素数分类

```
1.利用大根堆直接暴力
```

### 400.第N位数字

```
模拟遍历，找出n个数字在数字长度为len的范围中，再找在第几个数字内部，在求模
注意模拟的条件边界情况，通过整形对与除法的切断，找出n在len中哪一个数字里第几个
```

### 1446.连续字符

```
因为是连续的，无论是双指针，我用的是单指针，模拟一遍即可
```

### 787.K站中转内最便宜的航班

```
Bellman-Ford算法改进
**两个改进都非常重点
1.原算法中，因为最长路径节点为V，所以一共循环V-1次，本次 起+K+末共k+2，所以循环K+1ci1
2.每一次循环中，对于改进路径 src——>v，必须**提前克隆dict[]数组**：这样保证伸缩的某个U节点，
不会在本次循环中被伸缩（src->u）路径本次一定没有被修改，相当与**保证了每次给所有路径最多添加一个中专站路径节点**
```

### 506.相对名次

```
简单模拟可以用hashmap存位次和分数，复制score排序得到分数排序
也可使用最大根堆存储，在弹出
```

### 133.克隆图

```
深拷贝（对于引用对象的调用和浅拷贝明显不同）
通过递归调用复制函数
1.new新对象，将复制对象的属性，方法等等剥开，直到底层
2.对其他对象（邻接等等），再次调用递归，返回等等
**注意要标记哪些已经被复制过了
```

### 2089.找出数组排序后的目标下标

```
有意思的在于排序的nlogn时间复杂度反而是高的，所以我们不要排序，直接统计
target第一个下标为比target数量少的个数，target的重复为他的数量，复杂度将为n
```

### 1005.K次取反后最大化的数组和

```
简单的模拟题
注意K与数组中负数个数的关系，
注意数组中0的个数
```

### 322.零钱兑换

```
动态规划，从0到目标金额，步长为一，所以相对前序条件只用+1，注意不要超过大小
```

### 638.大礼包

```
将每份商品礼包化处理，在dfs，配合剪枝调优
```

### 2090.半径为k的子树组平均值

```
简单模拟，保存状态
```

### 372.超级次方

```
快速幂：见代码写法，分治求解,代码为利用非递归位运算的写法——将二分处理奇数化为1，2，4，8，16....的线性组合
(a*b)%mod = (a%mod * b%mod)%mod
将主幂次将为两个在0-10的数，然后在递归求解
a&1==1 a为奇数

aK=a(⌊10K⌋∗10)+(Kmod10)=a(⌊10K⌋∗10)∗a(Kmod10)=(a⌊10K⌋)10∗a(Kmod10)


```
### 1034.边界着色
    BFS遍历，通过检查该模块四周是否都是同色来判断是否是边界，然后染色，最后记得把边界外面的染色（ans中）

### 689.三个无重叠子数组的最大和
    滑动窗口，将三个长度为k的窗口一起滑动
    **i=2*k为初始态，作为第三个数组的尾标记,当i加到3*k-1时（每个数组都尾加k个元素后）开始判断遍历
    当sum1>max1时，更新max1和idx1
    !!!其实后面的递归看来[]idx2可以作为两个无重叠字数组的最大和
    当max1+sum2>max12时，更新max12和[]idx2（idx2[0]=idx1,idx2[1]=i-2*k+1）
    当max12+sum3>max123时，更新max123和[]idx3（idx3[0]=idx2[0],idx3[1]=idx2[1],idx3[2]=i-k+1），
    并更新[]ans(ans=idx3)<---可看作本类问题的一个终止点
    
    *本题方法对于n个无重叠子数组都可以延伸
    *还可以用动态规划求解

### 794.有效的井字游戏
    模拟遍历输入数字，把所有情况判断一遍，时间复杂度O（n）

### 748.最短补全词
    词频统计，处理时后记得将大学字母处理为小写字母

### 911.在线选举
    通过记录每个时间段是哪一位总统当选，然后查找的时候利用时间递增的规则，二分查找到当前总统票数领先
    中间有个二分法是mid=(l+r+1)>>1，这+1是为了防止后面的操作中死循环
    
### 709.转换成小写字母
    学习下新函数 toLowerCase()

### 807.保持城市天际线
    贪心算法，计算出每一个坐标下楼高与作出该行该列最大值中较小的差之和

    
### 630.课程表 III
    经典贪心算法
    course中，course[i][0]为课程持续时间，course[i][1]为课程结束时间
    将course按结束时间升序排序，再建立大根优先队列q储存每一个选中课程的时间
    对于每一个course，优先入队，sum+=course;
    如果sum+course[0]<=course[1],则相容，跳到下一个course
    如果不相容同样加入，但是sum-=q.poll()弹出里面耗费时间最长的（可能是刚刚加入的）

    证明：对于数量x的课程，要么是从x-1中相容加入，要么是从x+1中弹出最长的，所以耗费时间一定是最短的
        贪心选择性：不相容情况下，一定会为后面留出最多的时间☝
                相容情况下，不加入相当于舍弃掉这个course，最后课程数量一定不会大于
        优化子结构：每个操作能够使得选课程容量+0 or +1，如果可以+2则证明子结构不是最优，矛盾

### 851.喧闹与富有
    首先利用拓扑排序建图，a比b有钱则建立a指向b的边,并且建立数组保存每个节点的入度，并将入度为0的节点入队
    弹出队列（t）然后查看t每一个相邻节点的quiet值，由于是按照拓扑排序，ans首先默认为自己，由于我们从入度为0
    的（更有钱的）往下遍历，如果quiet（t）<quiet(u)，则可以更新!!!ans(u),不是t，并且每次都是改变相邻的，所以一定是由比自己更有钱的遍历而来，保证了更新的答案正确性
    注意答案是人的标号而不是安静值


### 1610.可见点的最大数目
    细节较多的数学题，求极角
    将角度排序，并且如果该点在观测点上，则另作保存处理
    有一个非常重要的操作，在将角度排序完成之后，为了防止从第四象限到第一象限（相对于观测点）的角可能会被忽略掉，所以我们要把保存角的元素每一个+2PI，扩充在表里，最后利用滑动窗口检测

### 1518.换酒问题
    可以简单的模拟做法
    也还有数学解法
    每一次交换m空酒瓶，会得到一个杯子和一个喝酒次数，所以每次损失m-1个杯子，
    总共能损失的个数/m-1为交换次数，加上原瓶子数即可
    注意，如果n一开始为m-1的倍数，则最后一次不会满足（无法交换）


### 36.有效的数独
    简单的模拟一次，从行列和3*3方格保存记录

### 42.接雨水
    二维的一个接雨水，对于每个坐标i而言其实能够接到的雨水为
    min(leftmax[i],rightmax[i])-height(i),左右同时遍历得到一个从
    i以左或者以右最大的高度（包括i）

    提高：还可以利用双指针，节省空间复杂度,左右指针只保存左指针以左，右指针以右的最大，在看那一边更小，则更新那一边 leftmax-height(left),left++
    证明重点：由于每次都挑选的更小那一边，可以反证
    max([0:left])<max([right:n-1])
    也就是说对i而言，左边一定存在一个比右边更大的值，则只用考虑与右边最大值相减即可。最后l与r重合（迭代结束的时候，所处的点为最高点，这里不会保留雨水，所以不用计算）

### 419.甲板上的战舰
    模拟遍历，从上到下从左到右，发现不相邻，则才能保证是一艘新的战舰

### 997.找到小镇的法官
    小镇法官不相信任何人，其他人都信任法官  
    对于一个图而言（节点）相当于出度为0，入度为n-1

### 156.上下翻转二叉树
    注意前提条件，本题是以左节点作为头节点翻转，所以树是向左生长的，不用递归右子树
    并且，其实翻转完之后，其实只是图的指向改变了，可能本身布局并没有发生变化，所以我们可以利用递归返回左子树新的根节点，再通过栈的回退从左往上修缮结构

### 475.供暖器
    答案具有二分性， 小于半径无法满足，大于等于答案半径可以满足
    相当于我们对于答案的所有范围二分法求解
    所以我们可以人为的设定R的范围[0:1e9],用二分的思路求的可以满足的上届
    利用check函数check（h,h,mid）如果可以覆盖返回true，如果不能覆盖返回false
    来看当前的mid是处于上届以上还是以下，再改动设定的R范围
    操作重点之一：遍历的时候，先到房子应该处于哪一个热水器的范围（之前需要排好序）
                当房子的位置大于供暖器i半径时，至少是属于i+1供暖器

### 1154.一年中的第几天
    简单模拟打表题，还可以用api操作
    字符串的拆解操作

### 2109.向字符串添加空格
    在规定位置添加空格，字符串操作题，本题由于是加在制定位置前面，所以可以从后往前遍历做，最后记得翻转一下
        

### 686.重复叠加字符串的匹配
    首先得到一个复制的上下届：
    首先复制后的下届n1*a>=b
    并且上届最多为n1+1（b从第一个a的最后一个字符开始匹配）
    反证可以得出如果大于n1+1,则前面也能匹配（重复复制的字符串）
    indexOf匹配利用了kmp
    

### 1044.最长重复字符串
    我们可以对每个长度的字符串遍历check找到有无重复的，但是这样复杂度较高，所以我们利用hashset，和字符串哈希表配合，每个长度的遍历负责度修正为O（n）
    重点1：长度具有二分性，大于上界的一定不存在，小于等于下届的一定存在
        这里使用的是r+l+1>>1;成功l=mid,不成功r=mid-1（由于二分性成功的mid包含性确定，如果成功，下一个边界一定包含mid，如果不成功下一个边界的r一定不包含mid）
        ！有的是反过来的mid=r+l>>1,这里要注意二分的用法
    重点2：如何构建字符串哈希表
        int P = 1313131, n = s.length();
        h = new long[n + 10]; p = new long[n + 10];
        p[0] = 1;
        for (int i = 0; i < n; i++) {
            p[i + 1] = p[i] * P;
            h[i + 1] = h[i] * P + s.charAt(i);
        }
        p[i]中表示P的i次方
        h[i]表示从第1位到第i位的hash值（有效下标1——n）
        如何表示当前字符子串的哈希值
        cur = h[j] - h[i - 1] * p[j - i + 1];
        ！！这里的P值是实验出来的，一般来说不行就可以改大一点，hash函数是有因为溢出带来的冲突引起的问题，所以这里我们已经使用了long数组来保存

### 187.重复的DNA序列
    上面提到过的hash字符串题的基础版本，练手用

### 2110.股票平滑下降阶段
    其实比较偏向数学解法的一道题
    首先由于每一天也算一个平滑下降，anx+=n first
    然后就是讨论两个以上的区间，这里有个处理的小技巧，比如说，从i到j他是平滑下降的，那么i到j就有1+2+...（i-j）个子区间为平滑下降的（区间的长度从i-j+1到2），这里我们可以通过窗口的扩大，同时处理这个累加，把他加到ans上。

### 1705.吃苹果的最大数目
    贪心和优先队列的结合题
    由于每次我们只能吃一个苹果，所以对于树上每天产生的苹果，我们会利用小根堆存起来，<过期时间，个数>，每次优先吃过期时间最早的苹果
    处理的时候，如果time在n之前，则每天还可以产生苹果，要考虑入堆的事情，
    出堆后要考虑苹果是否过期，或者没过期的苹果是否吃完，分别作处理
    最后直到堆中元素全部退完

### 1944.队列中可以看到的人
    这道题按照要求来说，对于i个人，他能够看到的人的个数（j1,j2,j3.....jn）一定满足严格的单调递增，并且如果jn右边还有元素存在那么jn，jn+1>=i，那么我们不妨维护一个严格单调递增（从顶部到底部）从右到左的栈：
    对于新元素i而言，栈中元素直到为空，或者出现第一个不比他小的元素！！！之后！！！，遍历到所有栈的元素一定能被i看到，且不能被i-1之前的元素看到。在对i看到元素看完了之后，我们再把i入栈，且此时i在栈中元素一定至少为最小（或者为最小之一），满足单调栈的结构性质且能让i-1做同样的操作遍历。
    ！Java的deque默认push是到头

### 1609.奇偶树
    由于这个需要遍历每一层的单调严格递增或者递减，所以我们优先采取BFS
    BFS的时候每一层我们都切换一下标志变量flag代表奇偶，对当前层数的奇偶递增要求进行判断，我们找到错误就可以返回

### 1078.Bigram 分词
    简单的字符串模拟罢了（差点忘记了Arraylist如何转为[]）

### 825.适龄的朋友
    首先我们首先将年龄排序，对于某一个年龄的人来说，交友请求的范围为比我小的不考虑，和我一样的或者比我大的（一定范围内考虑）（这里是以受到请求的人为中心考虑）
    那么其实对于每个人来说求友的范围可以用双指针来解决
    （本体来说能做朋友的指针下标为i,i+1,...j-1 not include k）
    还有筒排序和前缀和的优化解法，后续步上

### 472.连接词 
    解法一：将字符串哈希化，这里做一个set表，再遍历每一个字符串中是否能含有两个set以上的词
    解法二：trie字典树！！！一定要先将单词按照升列排序，去掉空单词，如果为非连接词则加入树，在遍历的时候每次遍历到重点就回到树的开头