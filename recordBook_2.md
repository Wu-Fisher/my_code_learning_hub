# Wufisher recordBook_2

thank ac_oier

update 2022/2/7  not catch

### 1001.网格照明 hard 2/8

    题目给的数据：网格范围高达1e9，如果直接硬遍历肯定会超时，但是由于我们发现灯的数量和查询数量只有e4级别，较小，所以我们就采用hash映射来解决稀疏的问题；

    hashmap 4个，分别记录col，row，left，right，每个hashmap的key是灯的位置，value是灯的状态，0表示灯灭，1表示灯亮；

    这里的Left 和 right 分别是左右对角线，映射key值为坐标x+y(x-y)非常巧妙。

    hashmap的value值为这里灯覆盖的层数，很好理解，比如一个灯灭了之后，只是他这个灯影响的光灭了，如果这个格子被其他灯照亮，则不会影响。


    然后再用一个hashset记录灯的位置，这里我们采用 x*n+y 转化为一维的形式记录来减小空间

    有趣的一点是，这个题查询后，只灭灯！！！，不灭光。（不过显然如果一个灯灭了，也会造成影响）


### 2006.差的绝对值为K的数对数目 easy 2/9

    数据范围小，也可以直接简单模拟统计

    优化的话用hash表统计数频，再计算数频差值的同时，更新hash表，便于后续比较


### 1447.最简分数 middle 2/10 
    这题由于n的数据量比较小，所以可以考虑枚举的方法

    所以问题转化为判断分数是否是最简分数->公约数是否为1

    这里学了两个求公约数的方法
    1.更相减损法：这个是需要实现高精度的时候适用

    ♥2.欧几里得算法：这个用递归很好写
    这里无需考虑判断 ab是否为0以及相对大小问题（这个其实看看递归是怎么写的就看出来了）

    int gcd(int a, int b) { // 欧几里得算法
        return b == 0 ? a : gcd(b, a % b);
    }






### 1984.学生分数的最小差值 easy 2/11


    排序之后，使用窗口长度为k的进行滑动（数据处理后的模拟一遍，就可以得到答案）

    这个ans默认不能一开始（哦不对好像也可以，- -
    ，哎就把这个留在这里作为对于简单题的反思吧）




