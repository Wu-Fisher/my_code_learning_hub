# Wufisher recordBook_2

thank ac_oier

update 2022/2/7  not catch

### 1001.网格照明 hard 2/8

    题目给的数据：网格范围高达1e9，如果直接硬遍历肯定会超时，但是由于我们发现灯的数量和查询数量只有e4级别，较小，所以我们就采用hash映射来解决稀疏的问题；

    hashmap 4个，分别记录col，row，left，right，每个hashmap的key是灯的位置，value是灯的状态，0表示灯灭，1表示灯亮；

    这里的Left 和 right 分别是左右对角线，映射key值为坐标x+y(x-y)非常巧妙。

    hashmap的value值为这里灯覆盖的层数，很好理解，比如一个灯灭了之后，只是他这个灯影响的光灭了，如果这个格子被其他灯照亮，则不会影响。


    然后再用一个hashset记录灯的位置，这里我们采用 x*n+y 转化为一维的形式记录来减小空间

    有趣的一点是，这个题查询后，只灭灯！！！，不灭光。（不过显然如果一个灯灭了，也会造成影响）


### 2006.差的绝对值为K的数对数目 easy 2/9

    数据范围小，也可以直接简单模拟统计

    优化的话用hash表统计数频，再计算数频差值的同时，更新hash表，便于后续比较


### 1447.最简分数 middle 2/10 
    这题由于n的数据量比较小，所以可以考虑枚举的方法

    所以问题转化为判断分数是否是最简分数->公约数是否为1

    这里学了两个求公约数的方法
    1.更相减损法：这个是需要实现高精度的时候适用

    ♥2.欧几里得算法：这个用递归很好写
    这里无需考虑判断 ab是否为0以及相对大小问题（这个其实看看递归是怎么写的就看出来了）

    int gcd(int a, int b) { // 欧几里得算法
        return b == 0 ? a : gcd(b, a % b);
    }






### 1984.学生分数的最小差值 easy 2/11


    排序之后，使用窗口长度为k的进行滑动（数据处理后的模拟一遍，就可以得到答案）

    这个ans默认不能一开始（哦不对好像也可以，- -
    ，哎就把这个留在这里作为对于简单题的反思吧）



### 1020.飞地的数量 middle 2/12

    这次我还是大致方向想对了，利用dfs和并查集

    （后补，其实我想的应该是多源BFS）
    其实这里更像是一个图论的深化吧，利用连通分量的一些性质，后面我写的三个函数也都是在处理找联通分量可以复用的函数

    1：从边界外的超级源点0开始连接着边界的陆地节点开始dfs
    2：并查集针对每一个陆地节点，简单来向就是，如果这个节点在之前的dfs中被搜到过，就加以标记，如果再次搜到，就跳过（显然那个点以及后续以及被操作搜索过了）

    **这里把每个点的标记x*N+y在一维进行标记
    **这里的N为n（矩阵宽度），没有什么特殊的处理，就是射在一维上（这么想来其实二位矩阵也没问题）

    老实说一开始没看懂叶总的题解代码，写一遍记录一下吧

    🐎核心来哩！，这个题里面的并查集不是简单的搜索过了，而是先把每个点标记为一个单独的联通分量

    union 将两个点编号连接起来
    find  查找该点属于哪一个联通分量
    query 判断两个点是否为一个联通分量


    🐱后面看了叶总第二个BFS感觉才像是我想到的做法，多源BFS，从边界陆地起点开始搜索，凡是能搜索到（出入队）的都是能够访问的节点。这里就用一个二维的vis来记录节点是否被访问过，访问过的也不用再次入队。

    最后再遍历即可得到没有被访问过的陆地节点个数

    ！！！做到这里我也得加一个任务
        ：把题型中可以复用的函数要拿出来记录一下


### 1189.气球的最大数量 easy 2/13   
    简单模拟统计一下词频就好，注意有两个字符的需要两个（统计时除以2）

### 540.有序数组中的单一元素 middle 2/14

    要求时间复杂度logn，那肯定要二分了，但是一开始我也没想到怎么常规的二分，后来看了叶总的脑筋急转弯思路大开。

    正常来说两个相同的数字同时出现，则一个数字在奇数位置，一个数字在偶数位置。当出现了单一元素后，则会发生数字的调换。

    🐎这里奇偶位置是一个相对关系：
    这样解释比较好，当你查到一个数的时候，如果该位置是偶数（数组下标从偶数0开始而不是奇数1），那么在单一位置前，应该查后面（偶数位置）一个数应该是相同的。
    当在单一数位置后则相反。我们便利用这个性质来调查二分。

    还是得注意一下二分法的一个状态判断，一般来说mid=l+r>>1，且mid可能为最后落脚点的 l = mid+1 || r = mid;(提醒合理选取二分边界的控制)

### 1308.矩阵中的幸运数 easy 2/15
    简单模拟一下，遍历记录一下


### 1719.重构一棵树的方案数 hard 2/16

    太苦难勒，过阵子再来补，今天早上属实是头疼了
    
    偷了一下网友的代码


### 688.骑士在棋盘上的概率 middle 2/17

    dp题，利用动态规划
    f[i][j][k]为从位置i,j出发，当前使用步数不超过k步，仍然在棋盘内的概率

    这里我们并不是从row,colum位置开始更新，而是对每一步，棋盘上的每一个点进行更新。
    f[i][j][p]=∑f[nx][ny][p−1]/8

    一开始我还没搞懂，为什么移动后的nx,ny反而变成了转移前的状态，关键就在于我们的f定义，是nx,ny为出发位置的概率。

    这里就可以相当于，我们从x,y出发，剩余k步，我们有1/8的概率走到nx，ny八个方向上，然后从nx,ny出发，有k-1个移动步数。此时这样就能理解上面的转移求和公式了

### 1791.找出星型图的中心 easy 2/18
    
    这题属于是特殊easy题了，- -
    直接两条边就能确定中心了
    这个中心就是真的中心（不是啥图论概念）


### 969.煎饼排序 middle 2/19

    这题的煎饼排序虽然是对0,k-1的翻转，但是并不是一种排序算法，只是一种操作手段。（本质上我们还是要用学过的排序算法来解决问题）

    这里是对前缀进行翻转，那么我们也可以想到用冒泡排序来解决问题。（每次决定最右端的值）

    那么我们如何把x放在我们想要他在的k-1位置上呢？（由于我们采用的是冒泡排序，k+1,n-1为有序递增段落）

    如果x在k-1上，则不做操作

    如果x在0上，则一次反转可以达到

    如果x在idx上（0<idx<k-1），则先（0，idx）反转，然后再转到上一个情况反转一次即可

    这里显然每个数到某一个位置只需要2次操作（由于只对前缀进行变换，不会影响后缀已经排序好的数）

    👆满足了我们所需要的少于10*array.length次操作要求。

    arr 是从 1 到 arr.length 整数的一个排列。题目如此要求，显然我们可以用一个idx[n+10]的数组来记录每个数的位置，方便我们排序使用。

### 717.1比特与2比特字符 easy 2/20

    由于1比特 0 
    2比特是10 或者11

    可以看出如果对于没有选择的话，遍历遇到的第一个为1，则只能2比特，如果遇到的是0，则只能1比特。

    然后根据情况模拟就ok