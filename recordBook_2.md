# Wufisher recordBook_2

thank ac_oier

update 2022/2/7  not catch

### 1001.网格照明 hard 2/8

    题目给的数据：网格范围高达1e9，如果直接硬遍历肯定会超时，但是由于我们发现灯的数量和查询数量只有e4级别，较小，所以我们就采用hash映射来解决稀疏的问题；

    hashmap 4个，分别记录col，row，left，right，每个hashmap的key是灯的位置，value是灯的状态，0表示灯灭，1表示灯亮；

    这里的Left 和 right 分别是左右对角线，映射key值为坐标x+y(x-y)非常巧妙。

    hashmap的value值为这里灯覆盖的层数，很好理解，比如一个灯灭了之后，只是他这个灯影响的光灭了，如果这个格子被其他灯照亮，则不会影响。


    然后再用一个hashset记录灯的位置，这里我们采用 x*n+y 转化为一维的形式记录来减小空间

    有趣的一点是，这个题查询后，只灭灯！！！，不灭光。（不过显然如果一个灯灭了，也会造成影响）


### 2006.差的绝对值为K的数对数目 easy 2/9

    数据范围小，也可以直接简单模拟统计

    优化的话用hash表统计数频，再计算数频差值的同时，更新hash表，便于后续比较


### 1447.最简分数 middle 2/10 
    这题由于n的数据量比较小，所以可以考虑枚举的方法

    所以问题转化为判断分数是否是最简分数->公约数是否为1

    这里学了两个求公约数的方法
    1.更相减损法：这个是需要实现高精度的时候适用

    ♥2.欧几里得算法：这个用递归很好写
    这里无需考虑判断 ab是否为0以及相对大小问题（这个其实看看递归是怎么写的就看出来了）

    int gcd(int a, int b) { // 欧几里得算法
        return b == 0 ? a : gcd(b, a % b);
    }






### 1984.学生分数的最小差值 easy 2/11


    排序之后，使用窗口长度为k的进行滑动（数据处理后的模拟一遍，就可以得到答案）

    这个ans默认不能一开始（哦不对好像也可以，- -
    ，哎就把这个留在这里作为对于简单题的反思吧）



### 1020.飞地的数量 middle 2/12

    这次我还是大致方向想对了，利用dfs和并查集

    （后补，其实我想的应该是多源BFS）
    其实这里更像是一个图论的深化吧，利用连通分量的一些性质，后面我写的三个函数也都是在处理找联通分量可以复用的函数

    1：从边界外的超级源点0开始连接着边界的陆地节点开始dfs
    2：并查集针对每一个陆地节点，简单来向就是，如果这个节点在之前的dfs中被搜到过，就加以标记，如果再次搜到，就跳过（显然那个点以及后续以及被操作搜索过了）

    **这里把每个点的标记x*N+y在一维进行标记
    **这里的N为n（矩阵宽度），没有什么特殊的处理，就是射在一维上（这么想来其实二位矩阵也没问题）

    老实说一开始没看懂叶总的题解代码，写一遍记录一下吧

    🐎核心来哩！，这个题里面的并查集不是简单的搜索过了，而是先把每个点标记为一个单独的联通分量

    union 将两个点编号连接起来
    find  查找该点属于哪一个联通分量
    query 判断两个点是否为一个联通分量


    🐱后面看了叶总第二个BFS感觉才像是我想到的做法，多源BFS，从边界陆地起点开始搜索，凡是能搜索到（出入队）的都是能够访问的节点。这里就用一个二维的vis来记录节点是否被访问过，访问过的也不用再次入队。

    最后再遍历即可得到没有被访问过的陆地节点个数

    ！！！做到这里我也得加一个任务
        ：把题型中可以复用的函数要拿出来记录一下


### 1189.气球的最大数量 easy 2/13   
    简单模拟统计一下词频就好，注意有两个字符的需要两个（统计时除以2）

### 540.有序数组中的单一元素 middle 2/14

    要求时间复杂度logn，那肯定要二分了，但是一开始我也没想到怎么常规的二分，后来看了叶总的脑筋急转弯思路大开。

    正常来说两个相同的数字同时出现，则一个数字在奇数位置，一个数字在偶数位置。当出现了单一元素后，则会发生数字的调换。

    🐎这里奇偶位置是一个相对关系：
    这样解释比较好，当你查到一个数的时候，如果该位置是偶数（数组下标从偶数0开始而不是奇数1），那么在单一位置前，应该查后面（偶数位置）一个数应该是相同的。
    当在单一数位置后则相反。我们便利用这个性质来调查二分。

    还是得注意一下二分法的一个状态判断，一般来说mid=l+r>>1，且mid可能为最后落脚点的 l = mid+1 || r = mid;(提醒合理选取二分边界的控制)