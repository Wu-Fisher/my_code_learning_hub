# recodebOOK_3

开第三本，主要是更改一下记录的格式

2022/3/11

### 2049.统计最高分的节点数目 middle 3/11 

:confused: :world_map:

又是邻接表建图

idx 值标记的是边 i标记的是节点原编号

e[idx] 保存该边指向的节点

he[i] 保存的是该点邻接的第一条边的idx值

ne[idx] 保存idx边保存邻接的下一条边

规则见题：简述为删除一个点后，

剩下的如果为一个连通块，则分数为他的节点数，

如果剩下的为多个，则为多个连通块相乘的积。

返回的是最多分数节点的个数

先建图，然后dfs得到f[] 保存每个节点作为根节点的子树的节点数目

对于大树的根节点来说 得分 a=Σ f[i] （i为0结点的子节点）

对于非根节点来说，删除该节点x后，a还应该乘上（n-f(x)）即根据树的定义，还有一个连通块的节点数等于n-f(x)并且相当于与x的子树通过x的入边相连接

### 590.N叉树的后序遍历 easy 3/12

后序遍历，直接dfs递归做法最快




### 平衡二叉树最多节点数计算

如果根节点高度为1（有的可以改为深度从0开始，反正1偏置）

S[1]=1,S[2]=2

S[i]=S[i-1]+S[i-2]+1

### 393.UTF-8编码验证

简单模拟

UTF-8是一个不定长的编码，最多由四个字节构成

字节1：0xxxxxxx

字节2：110xxxxx 10xxxxxx

字节3：1110xxxx 10xxxxxx 10xxxxxx

字节4：11110xxx 10xxxxxx 10xxxxxx 10xxxxxx

重点在于怎么写这个判断模拟的地方

由于输入的是数组，所以我们要根据第一个数字的前缀拍段一共多少字节有效

😅住了家人们，原来这个题不是判断某几个字节是不是一个UTF8，而是一串序列，相当于一段字符。

所以这个循环得判断多一点通俗一点

接上得到cnt如果是有效的话，检测该cnt个后续字节是否满足标准，然后再跳转到下一个UTF8开头进行下一个循环

期间可以针对cnt，data[]内字节的长度等进行长度判断提前退出（也是防止越界）



### 599.两个列表的最小索引总和 easy 3/14

哈希表模拟题

先用哈希表记录第一个序列的值和索引值

再遍历第二个，再通过哈希表的查询以及索引值的大小，来添加，清空重置，或者跳过答案值

### 2044.统计按位或能得到最大值的子集数目 middle 3/15

首先说到子集统计，如果集合本身个数不多的情况下，可以选择利用int或者long的比特位来统计i位是否被本次子集统计使用

当然有的情况也可以针对当前子集里面部分数的多少来，也可能数频统计获得一定的加速

1994.好子集的数目 之前做过，困难题，到时候可以一并做做。

其一优化，状压DP

在之前的遍历中，对于state递增的趋势而言，显然有一部分被重复计算了，所以我们加入DP数组

f[state] = f[state-lowbit]|num[idx]

转移方程简单来说就是把state中最低的1剃掉（state-lowbit）然后取并num[idx]

~~注意这里求得是最低，不是最高
并不是类似于1110= 1000 + 0110这种扩展，鹅好像也不是不可以，可以试试~~

好吧其实也可以 状态s我们是递增遍历
假如状态1110 可以由 1000+0110 得到
也可以由 1100 + 0010 得到，重要的是dp的思想

求得最低1比特位 lowbit = (s &-s) 学到了

这个lowbit以及对应的idx值我们用个hashmap来存储


### 432.全O(1)的数据结构

设计一个用于储存字符串计数的数据结构，能够返回计数最小和最大的字符串（由题目可知复杂度要求）

虽然插入的长度不超过10，但是哈希表仅仅能够做到O(1)的计数，无法做到O(1)的查询

采取LFUCache的思路，自定义节点并手写双链表
    
前置 🧀 146. LRU 缓存机制

### 146.LRU缓存 middle 3/17

实现一个最近最少使用缓存约束的数据结构，删除最后使用

用set储存是否已经被储存

并建立双向链表储存

如果已经储存，则把节点移动到表头refresh

如果未储存，容量未满，则加入到表头

如果储存已满，则删掉表尾节点，再加入表头

(以上操作均对应代码中的函数)

减少左右节点的判空操作，我们可以头尾建立两个哨兵节点（key=-1,value=-1）作为


### 720.词典中最长的单词 middle 3/17

这个最长需要单词由给定字符串序列中其他词汇挨个构成

比如"word" 还必须要有"w""wo""wor"

数据量小，本身可以set来做，但是这里我复习一下trie树

str.compareTo(str2) 比较两个字符串asc码大小，可以用于返回最小序列，如果返回>0 则为str更大

### 2043.简易银行系统 middle 3/18

简单模拟操作即可，不用搞花的

麻，用例来花的，超出用户的，用户标号比下标加一😅

